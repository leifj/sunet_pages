<!DOCTYPE html>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" lang="en-us" xml:lang="en-us" data-mc-search-type="Stem" data-mc-help-system-file-name="index.xml" data-mc-path-to-help-system="../../../" data-mc-target-type="WebHelp2" data-mc-runtime-file-type="Topic" data-mc-preload-images="false" data-mc-in-preview-mode="false" data-mc-medium="non-print" data-mc-toc-path="Product Overview|Configurations">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>High Availability (HA) Configurations</title>
        <link href="../../../Skins/Default/Stylesheets/Slideshow.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/TextEffects.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Topic.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Components/Styles.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../Resources/TableStyles/Breadcrumbs.css" rel="stylesheet" />
        <link href="../../Resources/Stylesheets/Gemalto_Template_Enterprise.css" rel="stylesheet" />
        <script src="../../../Resources/Scripts/custom.modernizr.js">
        </script>
        <script src="../../../Resources/Scripts/jquery.min.js">
        </script>
        <script src="../../../Resources/Scripts/require.min.js">
        </script>
        <script src="../../../Resources/Scripts/require.config.js">
        </script>
        <script src="../../../Resources/Scripts/foundation.min.js">
        </script>
        <script src="../../../Resources/Scripts/plugins.min.js">
        </script>
        <script src="../../../Resources/Scripts/MadCapAll.js">
        </script>
    </head>
    <body>
        <table style="width: 100%;border-spacing: 0px 0px;mc-table-style: url('../../Resources/TableStyles/Breadcrumbs.css');border-left-style: none;border-left-width: 1px;border-left-color: #000000;border-right-style: none;border-right-width: 1px;border-right-color: #000000;border-top-style: none;border-top-width: 0px;border-top-color: #000000;border-bottom-style: solid;border-bottom-width: 2px;border-bottom-color: #e6e6e6;" class="TableStyle-Breadcrumbs" cellspacing="0">
            <col style="width: 41px;" class="TableStyle-Breadcrumbs-Column-Column1" />
            <col class="TableStyle-Breadcrumbs-Column-Column1" />
            <tbody>
                <tr class="TableStyle-Breadcrumbs-Body-Body1">
                    <th class="TableStyle-Breadcrumbs-BodyB-Column1-Body1">
                        <p class="home" style="font-weight: normal;"><a href="../../Home_sa.htm">Home</a> &gt;
                        </p>
                    </th>
                    <th class="TableStyle-Breadcrumbs-BodyA-Column1-Body1">
                        <div class="MCBreadcrumbsBox_0"><span class="MCBreadcrumbsPrefix">  <![CDATA[ ]]></span><span class="MCBreadcrumbsSelf">Product Overview</span><span class="MCBreadcrumbsDivider"> &gt; </span><a class="MCBreadcrumbsLink" href="configurations.htm">Configurations</a><span class="MCBreadcrumbsDivider"> &gt; </span><span class="MCBreadcrumbs">High Availability (HA) Configurations</span>
                        </div>
                    </th>
                </tr>
            </tbody>
        </table>
        <h2>High Availability (HA) Configurations</h2>
        <p>SafeNet HSM products include availability and scalability capabilities for mission critical applications that require uninterrupted up-time.  These features allow the grouping of multiple devices into a single logical group – known as an HA (High Availability) group.  When an HA group is defined, cryptographic services remain available to the consuming applications as long as at least one member in the group remains functional and connected to the application server.  In addition many cryptographic commands are automatically distributed across the HA group to enable linear performance gains for many applications.  The following sections describe these features and the available configuration options in detail to help you understand how best to configure the HA groups for their application and environment.</p>
        <h3>Overview</h3>
        <p>The SafeNet high-availability (HA) and load balancing (LB) functionality is implemented in the HSM client libraries, and uses the SafeNet <a href="javascript:void(0);" class="MCTextPopup MCTextPopupHotSpot MCTextPopup_Open glossaryTerm MCTextPopupHotSpot_" alt="Closed" data-mc-alt2="Open">cloning<span class="MCTextPopupBody popupBody"><span class="MCTextPopupArrow"></span>The duplication or copying of HSM or application partition contents to other HSMs or application partitions that share the cloning domain secret. Cloning copies objects (certificates, keys, data), in a secure manner, via trusted path, from the user space on one HSM to an equivalent space on a second HSM. The trusted path can be direct connection between HSMs or application partitions on the same host, or can be via Remote Backup Protocol (RBC) between distant HSMs.</span></a> function to replicate/synchronize content across HA-group members.  The HSMs and appliances are not involved and, except for being instructed to clone objects to certain HSMs during a synchronization operation, are unaware that they might be configured in an HA group.  This allows you to configure HA on a per-application basis.  On each application server, define an HA group by first registering the server as normal clients to all the desired HSMs, then use client-side administration commands to define the HA group and set any desired configuration options.  You can configure several options including: </p>
        <p class="ul1" data-mc-autonum="&lt;b&gt;•&lt;/b&gt;"><span class="autonumber"><span class="ul1Bullet"><b>•</b></span></span>setting automatic or manual recovery mode; </p>
        <p class="ul1" data-mc-autonum="&lt;b&gt;•&lt;/b&gt;"><span class="autonumber"><span class="ul1Bullet"><b>•</b></span></span>setting some HSMs as standby members; and </p>
        <p class="ul1" data-mc-autonum="&lt;b&gt;•&lt;/b&gt;"><span class="autonumber"><span class="ul1Bullet"><b>•</b></span></span>performing various manual synchronization and recovery operations.    </p>
        <p>Once defined, the library presents to the application a virtual HSM that is a consolidation of all the physical HSMs in the HA group.  From this point on the library distributes operations and automatically synchronizes key material transparently to the application.</p>
        <p>
            <img src="../../Resources/Images/ha/ha_overview_cdunn_1.png" />
        </p>
        <h3>High Availability</h3>
        <p>As of SafeNet HSM release 6.x, the SafeNet high availability function supports the grouping of up to thirty-two members.  However,  the maximum practical group size for your application is driven by a trade-off between performance and the cost of replicating key material across the entire group.   A common practice is to set the group size to N+1 where N is defined by the desired performance per application server(s).  As depicted below, this solution gives the desired performance with a single extra HSM providing the availability requirement.  The number of HSMs per group of application servers varies based on the application use case but, as depicted, groups of three are typical. </p>
        <p>&#160;</p>
        <p>
            <img src="../../Resources/Images/ha/ha_high-avail_cdunn_2.png" />
        </p>
        <p>&#160;</p>
        <p>As performance needs grow beyond the performance capacity of three HSMs, it often makes sense to define a second independent  group of application servers and HSMs to further isolate applications from any single point of failure.  This has the added advantage of facilitating the distribution of HSM and application sets in different data centers.</p>
        <p>&#160;</p>
        <p>
            <img src="../../Resources/Images/ha/ha_high-avail-grow_cdunn_3.png" />
        </p>
        <p>For detailed discussion of the HA&#160;feature, its constraints and parameters, and how to configure and use HA, refer to the SafeNet HSM Administration Guide.</p>
        <p>Whenever an application creates key material, the HA functionality transparently replicates the key material to all members of the HA group before reporting back to the application that the new key is ready.   The HA library always starts with what it considers its primary HSM (initially the first member defined in an HA group).  Once the key is created on the primary it is automatically replicated to each member in the group. If a member fails during this process the key replication to the failed member is aborted after the fail-over time out .  If any member is unavailable during the replication process (that is, the unit failed before or during the operation), the HA library keeps track of this and  automatically replicates the key when that member rejoins the group .  Once the key is replicated on all active members of the HA group a success code is returned to the application.</p>
        <h3>Load Balancing</h3>
        <p>The default behavior of the client library is to attempt to load-balance the application’s cryptographic requests across the entire set of devices in the HA group.  The top level algorithm is a round-robin scheme that is modified to favor the least busy device in the set.  As each new command is processed the SafeNet HSM client looks at how many commands it has scheduled on every device in the group.  If all devices have an equal number of outstanding commands the new command is scheduled on the next device in the list – creating a round-robin behavior.  However, if the devices have a different number of commands outstanding on them, the new command is scheduled on the device with the fewest commands queued – creating a least-busy behavior. This modified round-robin has the advantage of biasing load away from any device currently performing a lengthy-command.  In addition to this least-busy bias, the type of command also affects the scheduling algorithm.</p>
        <p>Single-part (stateless) cryptographic operations are load-balanced.  However, multi-part (stateful) and key management commands are not load-balanced.  Multi-part operations carry cryptographic context across individual commands.  The cost of distributing this context to different HA group members is generally greater than the benefit.  For this reason multi-part commands are all targeted at the primary member.  Multi-part operations either are not used or are infrequent actions, so most applications are not affected by this restriction.  Key management commands affect the state of the keys stored in the HSM.  As such, these commands are targeted at all HSMs in the group. That is the command is performed on the primary HSM and then the result is replicated to all members in the HA group.    Key management operations are also an infrequent occurrence for most applications .</p>
        <p>It is important to understand that the least-busy algorithm uses the number of commands outstanding on each device as the indication of its busyness.  When an application performs a repeated command set, this method works very well. However, when the pattern is interrupted, the type of command can have an impact.   For example, when the HSM is performing signing and an atypical asymmetric key generation request is issued, some number of the application’s signing commands are scheduled on the same device (behind the key generation).  Commands queued behind the key generation therefore have a large latency driven by the key generation.  However, the least-busy characteristic  automatically schedules more commands to other devices in the HA group, minimizing the impact of the key generation.</p>
        <p>It is also important to note that the load-balancing algorithm operates independently in each application process.  Multiple processes on the same client or on different clients do not share their “busyness” information while making their scheduling choice.  In most cases this is reasonable, but some mixed use cases might cause certain applications to hog the HSMs.</p>
        <p>Finally, when an HA group is shared across many servers, different initial members can be selected while the HA group is being defined on each server.  The member first assigned to each group becomes the primary.  This approach optimizes an HA group to distribute the key management and/or multi-part cryptographic operation load more equally.</p>
        <p>In summary, the load-balancing scheme used by SafeNet is a combination of round-robin and least-busy for most operations.  However, as required, the algorithm adapts to various conditions and use cases so it might not always emulate a round-robin approach.</p>
        <h3>Failover</h3>
        <p>When an HA group is running normally the client library continues to schedule commands across all members as described above.  The client continuously monitors the health of each member at two different levels.  First, the connectivity with the member is monitored at the networking layer.  Disruption of the network connection invokes a fail-over event within a twenty second timeout . Second, every command sent to a device is continuously monitored for completion.  Any command that fails to complete within twenty  seconds also invokes a fail-over event.  Most commands are completed within milliseconds.  However, some commands can take extended periods to complete – either because the command itself is time-consuming (for example, key generation); or because the device is under extreme load.   To cover these events the HSM automatically sends “heartbeats” every two seconds for all commands that have not completed within the first two seconds.  The twenty second timer is extended every time one of these heartbeats arrives at client, thus preventing false fail-over events.</p>
        <p>A fail-over event involves dropping a device from the available members in the HA group.  All commands that were pending on the failed device are transparently rescheduled on the remaining members of the group.  So when a failure occurs, the application experiences a latency stall on some of the commands in process (on the failing unit) but otherwise sees no impact on the transaction flow .  Note that the least-busy scheduling algorithm automatically minimizes the number of commands that stall on a failing unit during the twenty second timeout.</p>
        <p>If the primary unit fails, clients automatically select the next member in the group as the new primary.  Any key management or single-part cryptographic operation are transparently restarted on a new group member.  In the event that the primary unit fails, any in-progress, multi-part, cryptographic operations must be restarted by the application, as the operation returns an error code.</p>
        <p>As long as one HA group member remains functional, cryptographic service is maintained to an application no matter how many other group members fail. As discussed in the Recovery section below, members can also be put back into service without restarting the application.</p>
        <h3>Recovery</h3>
        <p>After a failure, the recovery process is typically straight-forward.  Depending on the deployment, an automated or manual recovery process might be appropriate.   In either case there is no need to restart an application!  </p>
        <p>With automatic recovery, the client library automatically performs periodic recovery attempts while a member is failed.  The frequency of these checks is adjustable and can be limited on the number of re-tries.   Each time a reconnection is attempted, one application command experiences a slight delay while the library attempts to recovery.  As such, the retry frequency cannot be set any faster than once per minute.  Even if a manual recovery process is selected the application does not need to be restarted.  Simply run the client recovery command and the recovery logic inside the client makes a recovery attempt the next time the application uses the HSM.  As part of recovery any key material created while the member was offline is automatically replicated to the recovered unit .</p>
        <p>Sometimes a failure of a device is permanent.  In this event, the only solution is to deploy a new member to the group.  In this case, remove the failed unit from the HA group, add a new device to the group and then kick the recovery process.  The running clients automatically resynchronize keys to the new member and start scheduling operations to it.</p>
        <p>Finally, sometimes both an HSM and application fail at the same time.  If, while an HSM was offline, no new key material was created the recovery is still straightforward: simply return the HSM to service and then restart the application.  However, if new key material was created after an HSM failed but before the application failed, a manual re-synchronization might be required.  Confirm which member or members have the current key material (normally the unit(s) that was online at the time the application failed). Put them back in service with the application. Then, for each member that has stale key material (a copy of an object that was deleted; or an old copy of an object who’s attributes were changed), delete all their key material after first making sure they are not part of the HA group. Be particularly careful that the member is not part of the HA group or the action might destroy active key material by causing an accidental synchronization during the delete operation!  After the HSM is cleared of key material, rejoin it to the group and the synchronization logic automatically repopulates the device’s key material from the active units.</p>
        <h3>Standby Mode</h3>
        <p>By default all members in an HA group are treated as active.  That is, they are both kept current with key material and used to load-balance cryptographic services.   In some deployment scenarios it makes sense to define some members as standby. Standby members are registered just like active members except, after they are added to the HA group, they are defined as “standby”. As depicted below, applications can be deployed in geographically dispersed locations.  In this scenario, use Luna’s standby capability to use the HSMs in the remote data center to cost effectively improve availability.  In this mode, only the local units (non-standby) are used for active load-balancing.  However, as key material is created they are automatically replicated to both the active (local) units and standby (remote) unit.   In the event of a failure of all local members the standby unit is automatically promoted to active status..  The primary reason for using this feature is to reduce costs while improving reliability and this approach allows remote HSMs that have high latency to be avoided when not needed.  However, in the worst case scenario where all the local HSMs fail, the remote member automatically activates itself and keeps the application running. &#160;&#160;</p>
        <p>
            <img src="../../Resources/Images/ha/ha_standby-mode_cdunn_4.png" />
        </p>
        <h3>Notes and More</h3>
        <p>It is important that all members in an HA group have the same configuration and version.  Running HA groups with different versions is unsupported. Ensure that HSMs are configured identically to ensure smooth high availability and load balancing operation. SafeNet HSMs come with various key management configurations: cloning mode, key-export mode, etc.  HA functionality is supported with both cloning and Scalable Key Storage variants – provided all members in the group have the same configuration.  Clients automatically and transparently use the correct secure key replication method based on the group’s configuration.</p>
        <p>It is also critical that all members in an HA group share the same Security Domain role (Red PED key for Trusted Path authentication devices and security domain password for password authenticated devices).  The Security Domain defines which HSMs are allowed to share key material. Because HA group members are, by definition, intended to be peers they need to be in the same Security Domain.</p>
        <p>By default the client library present both physical slots and virtual slots for the HA group.  Directing applications at the physical slots bypasses the high availability and load balancing functionality.  An application must be directed at the virtual slots to activate the high availability and load balancing functionality.  A configuration setting referred to as HAonly  hides the physical slots.  SafeNet recommends using this setting to prevent incorrect application configurations. Doing so also simplifies the PKCS #11 slot ordering given a dynamic HA group</p>
        <p>Application developers should be aware that the PKCS #11 object handle model is fully virtualized with the SafeNet HA logic.  As such, the application must not assume fixed handle numbers across instances of an application.  A handle’s value remains consistent for the life of a process; but it might be a different value the next time the application is executed.</p>
        <p>The network topography of the HA group is generally not important to the proper functioning of the group.  As long as the client has a network path to each member the HA logic will function.   Keep in mind that having a varying range of latencies between the client and each HA member causes a command scheduling bias towards the low-latency members.  It also implies that commands scheduled on the long-latency devices have a larger overall latency associated with each command.  In this case, the command latency is a characteristic of the network; to achieve uniform load distribution ensure that  latencies to each device in the group are similar (or use standby mode).</p>
        <p>The SafeNet HA and load-balancing feature works on a per-client and per-partition bases.  This provides a lot of flexibility.  For example, it is possible to define a different sub-set of HSMs in each client and even in each client’s partitions (in the event that a single client uses multiple partitions).   SafeNet recommends to avoid these complex configurations and to keep the HA topography uniform for an entire HSM.  That is, treat HSM members at the HSM level as atomic and whole.  This simplifies the configuration management associated with the HA feature.</p>
        <p>When a client is configured to use automatic recovery the manual recovery commands must not be used.  Invoking them can cause multiple concurrent recovery processes which result in error codes and possible key corruption .</p>
        <p>Most customers should enable automatic recovery in all configurations.  We anticipate that the only reason you might wish to choose manual recovery is if you do not want to impart the retry time to periodic transactions.  That is, each time a recovery is attempted a single application thread experiences an increased latency while the library uses that thread to attempt the re-connection (the latency impact is a few hundred milliseconds).</p>
        <h3>Example: Database Encryption</h3>
        <p>This section walks through a specific sample use case of some of the HA logic with a specific application – namely a transparent database encryption.</p>
        <h4>Typical Database Encryption Key Architecture</h4>
        <p>Database engines typically use a two-layered key architecture.  At the top layer is a master encryption key that is the root of data protection.  Losing this key is equivalent to losing the database, so it obviously needs to be highly durable.  At the second layer are table keys used to protect table-spaces and/or columns.  These table keys are stored with the database as blobs encrypted by the master encryption key.  This architecture maps to the following operations on the HSM:</p>
        <p>1.	Initial generation of master key for each database.</p>
        <p>2.	Generation  and encryption of table keys with the master key.</p>
        <p>3.	Decryption of table keys when the database needs to access encrypted elements.</p>
        <p>4.	Generation of new master keys during a re-key and then re-encrypting all table keys with it.</p>
        <p>5.	Generation and encryption of new table keys for storage in the database (often done in a software module).</p>
        <p>The HSM is not involved in the use of table keys.  Instead it provides the strong protection of the MEK which is used to protect the table keys.  Users must follow backup procedures to ensure their MEK is as durable as the database itself.  Refer to the backup section of this manual for proper backup procedures.</p>
        <h4>HSM High Availability with Database Encryption</h4>
        <p>When the HSMs are configured as an HA group the database’s master key is automatically and transparently replicated to all the members when the key is created; and each time it is re-keyed.   If an HSM group member was offline or fails during the replication it does not immediately receive a copy of the key.  Instead the HA group proceeds after replicating to all of the active members.  Once a member is re-joined to the group the HSM client automatically replicates the new master keys to the recovered member.</p>
        <p>With this in mind, before every re-key event the user should ensure the HA group has sufficient redundancy.  A re-key will succeed so long as one HA group member exists, but proceeding with too few HSMs will result in an availability risk.  For example, proceeding with only one HSM means the new master key will be at risk since it exists only on a single HSM. Even with sufficient redundancy, SafeNet recommends maintaining an offline backup of a database’s master key.</p>
        <h4>HSM Load Balancing with Database Encryption</h4>
        <p>While a database is up and running the master key exists on all members in the HA group.  As such, requests to encrypt or decrypt table keys are distributed across the entire group.  So the load-balancing feature is able to deliver improved performance and scalability when the database requires a large number of accesses to the table keys.  With that said, most deployments will not need much load-balancing as the typical database deployment results in a small number of table keys.</p>
        <p>While the table keys are re-keyed, new keys are generated in the HSM and encrypted for storage in the database.   Within an HA group, these keys are generated on the primary HSM and then, even though they exist on the HSM for only a moment, they are replicated to the entire HSM group as part of the availability logic.   These events are infrequent enough that this extra replication has minimal impact.</p>
        <h3>Conclusion</h3>
        <p>The SafeNet high availability and load balancing features provide an excellent set of tools to scale applications and manage availability of cryptographic services without compromising the integrity of cryptographic keys.  They do not need to be copied out of an HSM and stored in a file to achieve high levels of availability.  Indeed, recovery from many failures is much more rapid with Luna’s keys-in-hardware approach since each HSM maintains its own copy of all keys directly inside it.  A broad range of deployment options are supported that allow solution architects to achieve the availability needed in a manner that optimizes the cost and performance without compromising the assurance of the solution.</p>
        <p class="footer"><span class="DefaultProduct">SafeNet Network HSM</span> <span class="DefaultRelease">6.2.2</span> <span class="DefaultProjectTitle">Product Documentation</span> <br /><span class="DefaultPartNumber">007-011136-012</span> <span class="DefaultRevision">Rev. A</span> <span style="color: #5e5e5c;"><![CDATA[  ]]></span> <span class="DefaultDateLong">01 December 2016</span> <span style="color: #5e5e5c;"><![CDATA[  ]]></span> <span class="DefaultCopyright">Copyright 2001-2016</span>&#160;<span class="DefaultCompanyNameLong">Gemalto</span> <span style="color: #5e5e5c;"><![CDATA[  ]]></span>All rights reserved. </p>
    </body>
</html>