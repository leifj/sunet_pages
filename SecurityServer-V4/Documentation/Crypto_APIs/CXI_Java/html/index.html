<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>CXI: Cryptographic eXtended Interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CXI
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Cryptographic eXtended Interface </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="content_sec"></a>
Content</h1>
<hr/>
<ul>
<li><a class="el" href="index.html#intro_sec">Introduction</a></li>
<li><a class="el" href="index.html#keystorage_sec">Key Storage</a></li>
<li><a class="el" href="index.html#auth_sec">Authentication</a></li>
<li><a class="el" href="index.html#sm_sec">Secure Messaging</a></li>
<li><a class="el" href="index.html#keyaccess_sec">Key Access Restrictions</a></li>
<li><a class="el" href="index.html#failover_sec">Failover</a></li>
<li><a class="el" href="index.html#prog_sec">Programming Interface</a></li>
<li><a class="el" href="index.html#example_sec">Examples</a></li>
<li><a class="el" href="index.html#install_sec">Installation</a></li>
<li><a class="el" href="index.html#requirements_sec">Requirements</a></li>
<li><a class="el" href="group__cxi__history.html">Change History</a></li>
</ul>
<h1><a class="anchor" id="intro_sec"></a>
Introduction</h1>
<hr/>
<p>The CXI API provides a general purpose Java interface to be used with the CryptoServer firmware module CXI.<br/>
 To use this interface the firmware module must be loaded into the CryptoServer and the application must have been linked against the library file 'CryptoServerCXI.jar'.</p>
<p>The CXI API supports two operating modes: </p>
<ul>
<li>
<p class="startli"><b>Dedicated Mode:</b> One instance of CXI represents a logical connection to one CryptoServer.<br/>
 This mode has to be used if a dedicated CryptoServer should be addressed (e.g. for key management).<br/>
</p>
<p class="endli"></p>
</li>
<li>
<b>Cluster Mode:</b> One instance of CXI represents a logical connection to a cluster of CryptoServer.<br/>
 This mode supports a failover mechanism, that automatically switches to another CryptoServer in case of a communication error.<br/>
 The API only returns an error if the communication to all devices failed or if the CryptoServer responds an application error.<br/>
<br/>
 </li>
</ul>
<p>See <a class="el" href="index.html#prog_sec">Programming Interface</a> how to apply an operating mode.<br/>
</p>
<p>The CXI API offers various cryptographic services:</p>
<ul>
<li><b>Constructors</b><ul>
<li>create instance that represents a logical connection to a dedicated CryptoServer</li>
<li>create instance that represents a logical connection to a cluster of CryptoServer</li>
<li>create instance based on a configuration file (either dedicated or cluster)</li>
</ul>
</li>
</ul>
<ul>
<li><b>Key Management</b><ul>
<li>key generation (DES, AES, RSA, ECDSA, DSA)</li>
<li>import and export of keys</li>
<li>backup and restore of keys</li>
<li>get/set key properties</li>
</ul>
</li>
</ul>
<ul>
<li><b>Cryptography</b><ul>
<li>encryption (DES, AES, RSA, ECIES)</li>
<li>signature generation (ECDSA, RSA)</li>
<li>signature verification (ECDSA, RSA)</li>
<li>MAC calculation (DES, AES)</li>
<li>MAC verification (DES, AES)</li>
<li>calculation of shared secrets (ECDSA)</li>
<li>generation of random bytes</li>
<li>HASH/HMAC computation</li>
</ul>
</li>
</ul>
<ul>
<li><b>Miscellaneous Functions</b><ul>
<li>execute arbitrary command on CryptoServer</li>
<li>get version of CXI API and CXI firmware module</li>
</ul>
</li>
</ul>
<p>The complete class overview can be found <a href="annotated.html"><b>here</b></a>.</p>
<h1><a class="anchor" id="keystorage_sec"></a>
Key Storage</h1>
<hr/>
<p>CXI identifies keys by their key name, key group and key specifier. The key name is mandatory, group and specifier are optional and may be omitted. In either case the combination of name, group and specifier has to be unique.<br/>
</p>
<p>Keys can either be stored on the CryptoServer (internally) or on the host PC (externally). On generation or import of keys the application can decide whether to store the key internally (internalStorage = true) or externally (internalStorage = false).<br/>
</p>
<p>An internal key is stored in the key database within the CryptoServer. The application receives a key handle linking to the key on the CryptoServer. In the case of an external key, the application receives a key blob containing key attributes and key components. Key components within a key blob are encrypted with the CryptoServer's Master Backup Key.<br/>
</p>
<p>CXI offers a key store (<a class="el" href="class_crypto_server_c_x_i_1_1_crypto_server_c_x_i_1_1_key_store.html">KeyStore</a>) that can be used to store external keys, but the application may also use other storage locations for external keys (e.g. key files).<br/>
</p>
<p>Any function on the CryptoServer that needs a key as input parameter (e.g. encryption or signature creation) accepts both key handles and key blobs. If a key handle is given the key is loaded from the CryptoServer's key database. If a key blob is given the key is decrypted with the Master Backup Key. Essentially the usage of internal and external keys can be mixed.</p>
<h1><a class="anchor" id="auth_sec"></a>
Authentication</h1>
<hr/>
<p>Any user who wants to execute security relevant commands on the CryptoServer has to authenticate to the CryptoServer. Some commands can either be executed by one user holding the exclusive permissions or by several users with shared permissions (e.g. Two-person/Four-eyes rule). In either case the CryptoServer adds all authenticated users' permission levels and checks whether the desired command may be executed.</p>
<p>The CryptoServer API supports the following authentication methods:</p>
<ul>
<li><b>RSA Signature and ECDSA Signature</b><br/>
 The command is signed with the private part of the RSA or ECDSA key and the CryptoServer verifies the signature with the public part of the key.<br/>
 The private part of the key (used to create the signature) can be stored on the following media: <ul>
<li>
plaintext key file </li>
<li>
password-encrypted key file </li>
<li>
smartcard (the smartcard reader has to be connected to the host PC)<br/>
  </li>
</ul>
<br/>
 In either case the public part of the key has to be imported into the CryptoServer on creation of the user.</li>
</ul>
<ul>
<li><b>RSA Smartcard</b><br/>
 This method is a special case of RSA Signature, where the smartcard reader is directly connected to the CryptoServer.</li>
</ul>
<ul>
<li><b>HMAC password</b><br/>
 Password authentication using a Hash-based Message Authentication Code.<br/>
 This is the recommended mechanism for password users.</li>
</ul>
<ul>
<li><b>SHA1 hashed password</b><br/>
 Password authentication using a SHA1 hashed password.<br/>
 Supported for legacy users. New users should use HMAC password (or a signature mechanism).</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>On a cluster of CryptoServer only password authentication is supported (see <a class="el" href="class_crypto_server_a_p_i_1_1_crypto_server_cluster.html">CryptoServerAPI.CryptoServerCluster</a>).</dd></dl>
<p>In order to apply an authentication method a user with the corresponding authentication mechanism is needed. The authentication mechanism has to be assigned on creation of the user and can't be changed later on.</p>
<p>Pure authentication (without secure messaging) can be applied by using one of the <b>prepareAuthenticationXXX</b> methods (see <a class="el" href="class_crypto_server_a_p_i_1_1_crypto_server.html">CryptoServerAPI.CryptoServer</a>).</p>
<h1><a class="anchor" id="sm_sec"></a>
Secure Messaging</h1>
<hr/>
<p>Instead of authenticating every command, the CryptoServer API allows creation of an encrypted 'Secure Messaging' session with the CryptoServer. Thereby the user only authenticates the creation of the session (exchange of the session key). The session 'remembers' the permissions of all users being logged in. Any command sent through this session is automatically authenticated with the combined permissions of the users.</p>
<dl class="section note"><dt>Note</dt><dd>If a session remains idle (no command was sent) for more than 15 minutes, the session expires and is automatically invalidated by the CryptoServer.<br/>
 Use <a class="el" href="class_crypto_server_a_p_i_1_1_crypto_server.html#ae09f5730178615dde4de7fd45048b6d8">CryptoServerAPI.CryptoServer.keepSessionAlive()</a> or <a class="el" href="class_crypto_server_a_p_i_1_1_crypto_server_cluster.html#ae09f5730178615dde4de7fd45048b6d8">CryptoServerAPI.CryptoServerCluster.keepSessionAlive()</a> to prevent a session from expiring.</dd></dl>
<p>A session can be created by using one of the <b>getSessionKeyXXX</b> methods (see <a class="el" href="class_crypto_server_a_p_i_1_1_crypto_server.html">CryptoServerAPI.CryptoServer</a>).</p>
<p>In order to simplify session creation the following methods combine authentication and secure messaging:</p>
<ul>
<li><a class="el" href="class_crypto_server_a_p_i_1_1_crypto_server.html#a754899025f580b46523a8af6bac88129">logonSign</a></li>
<li><a class="el" href="class_crypto_server_a_p_i_1_1_crypto_server.html#a58ade920d99eae1875d9324497b75876">logonPassword</a></li>
<li><a class="el" href="class_crypto_server_a_p_i_1_1_crypto_server.html#a36eda859ee0a2b35349a37892f605228">logoff</a></li>
</ul>
<h1><a class="anchor" id="keyaccess_sec"></a>
Key Access Restrictions</h1>
<hr/>
<p>Any user who wants to access an - internal or external - key has to authenticate to the CryptoServer (see above).</p>
<p>If a key has been assigned to a group (on key generation or import), it may only be accessed by a user who is a member of the same group. To achieve this, the user attribute 'CXI_GROUP' has to be set on creation of the user. The CXI_GROUP attribute may also contian wildcards '*' or question marks '?' in order to assign a user to multiple groups.<br/>
</p>
<p>Examples:<br/>
 </p>
<ul>
<li>
<p class="startli"><b>User 1: CXI_GROUP=test</b><br/>
 This user may only access keys with the group attribute 'test', other keys are 'invisible' for the user.<br/>
</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>User 2: CXI_GROUP=test*</b><br/>
 This user may only access whose entity attributes start with 'test' (e.g. 'test', 'test01', 'test_xxx'), other keys are 'invisible' for the user.<br/>
</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>User 3: CXI_GROUP=*</b><br/>
 This user is allowed to access all keys.<br/>
</p>
<p class="endli"></p>
</li>
</ul>
<p>If no group attribute has been set for a key, the key may be accessed by all users regardless of their group membership.</p>
<h1><a class="anchor" id="failover_sec"></a>
Failover</h1>
<hr/>
 CXI provides fault tolerant operation on a CryptoServer cluster. In case of communication errors the API automatically switches to the next device and tries to execute the command on that CryptoServer. Only if the API wasn't able to execute the command on any device, it gives up and throws an exception.<br/>
</p>
<p>After having successfully switched to another device the API stays connected to this device and does not switch back. Optionally a fallback interval time may be configured causing the API to switch back to the first (primary) device of the device list after a certain amount of time.<br/>
</p>
<p>CryptoServerCXI also provides an event handler interface to obtain information about state changes and errors occurring on the cluster.<br/>
 By default the event handler messages are written to the default log file (see <a class="el" href="class_crypto_server_c_x_i_1_1_crypto_server_c_x_i.html#accb03b5010ea29003477b310f1fdfe65">CxiLog</a> ).<br/>
 The application may also implement its own event handler and register it, see CryptoServerCluster.setEventHandler(CryptoServerCluster.EventHandler).</p>
<h1><a class="anchor" id="prog_sec"></a>
Programming Interface</h1>
<hr/>
 In order to use the CXI API the application has to be linked against the CXI library file (CryptoServerCXI.jar).<br/>
 The API consists of its main class CXI and several other classes that are needed to deal with objects (e.g. keys, properties, configuration).<br/>
</p>
<p>Main class:</p>
<ul>
<li><a class="el" href="class_crypto_server_c_x_i_1_1_crypto_server_c_x_i.html">CryptoServerCXI</a></li>
</ul>
<p>Other classes:</p>
<ul>
<li><a class="el" href="class_crypto_server_a_p_i_1_1_crypto_server.html">CryptoServer</a></li>
<li><a class="el" href="class_crypto_server_a_p_i_1_1_crypto_server_cluster.html">CryptoServerCluster</a></li>
<li><a class="el" href="class_crypto_server_a_p_i_1_1_crypto_server_exception.html">CryptoServerException</a></li>
<li><a class="el" href="class_crypto_server_a_p_i_1_1_crypto_server_config.html">CryptoServerConfig</a></li>
<li><a class="el" href="class_crypto_server_a_p_i_1_1_crypto_server_log.html">CryptoServerLog</a></li>
<li><a class="el" href="class_crypto_server_a_p_i_1_1_crypto_server_util.html">CryptoServerUtil</a></li>
</ul>
<p>The complete class overview can be found <a href="annotated.html"><b>here</b></a>.</p>
<p>CXI offers three constructors to be used for different purposes:</p>
<ul>
<li><a class="el" href="class_crypto_server_c_x_i_1_1_crypto_server_c_x_i.html#a8a355959889f4ec80fada687f193461b">CryptoServerCXI.CryptoServerCXI.CryptoServerCXI(String device, int timeout)</a><br/>
 Opens the specified CryptoServer with the given connection timeouts. Use this constructor if you want to use a single device exclusively.</li>
</ul>
<ul>
<li><a class="el" href="class_crypto_server_c_x_i_1_1_crypto_server_c_x_i.html#a7bdfebfa4e7b61da5da4a08eb203e94c">CryptoServerCXI.CryptoServerCXI.CryptoServerCXI(String [] devices, int timeout)</a><br/>
 Opens multiple CryptoServers as a cluster. Use this constructor if you want to set up a fault-tolerant system that supports failover.</li>
</ul>
<ul>
<li><a class="el" href="class_crypto_server_c_x_i_1_1_crypto_server_c_x_i.html#a20e9adac95316ebcfae6103911d19873">CryptoServerCXI.CryptoServerCXI.CryptoServerCXI</a>(<a class="el" href="class_crypto_server_a_p_i_1_1_crypto_server_config.html" title="This class provides methods to read and parse configuration files and access configuration items...">CryptoServerAPI.CryptoServerConfig</a> config)<br/>
 Reads the device configuration from the given configuration file. Here you can either configure a single device (e.g. 'Device = PCI:0') or multiple devices as a cluster<br/>
 (e.g. 'Device = PCI:0 192.168.4.1 192.168.4.2').</li>
</ul>
<dl class="section note"><dt>Note</dt><dd><b>Don't use cluster mode if a dedicated CryptoServer should be addressed!</b></dd></dl>
<h1><a class="anchor" id="example_sec"></a>
Examples</h1>
<hr/>
<p>The following code illustrates how to manage keys with the CXI API: </p>
<div class="fragment"><div class="line"><span class="keyword">import</span> CryptoServerAPI.*;</div>
<div class="line"><span class="keyword">import</span> CryptoServerCXI.*;</div>
<div class="line"></div>
<div class="line"><span class="comment">// create instance of CryptoServerCXI (opens connection to CryptoServer)</span></div>
<div class="line">CryptoServerCXI cxi = <span class="keyword">new</span> CryptoServerCXI(<span class="stringliteral">&quot;192.168.4.1&quot;</span>, 3000);</div>
<div class="line">cxi.setTimeout(60000);</div>
<div class="line"></div>
<div class="line"><span class="comment">// logon a user with smartcard authentication (has to be a member of group &#39;test&#39;)</span></div>
<div class="line">cxi.logonSign(<span class="stringliteral">&quot;CXI_RSA&quot;</span>, <span class="stringliteral">&quot;:cs2:cyb:USB0&quot;</span>, NULL);</div>
<div class="line"></div>
<div class="line"><span class="comment">// create a key</span></div>
<div class="line">CryptoServerCXI.KeyAttributes attr = <span class="keyword">new</span> CryptoServerCXI.KeyAttributes();</div>
<div class="line">attr.setAlgo(CryptoServerCXI.KEY_ALGO_AES);</div>
<div class="line">attr.setSize(256); </div>
<div class="line">attr.setGroup(<span class="stringliteral">&quot;test&quot;</span>);</div>
<div class="line">attr.setName(<span class="stringliteral">&quot;AES test key&quot;</span>);</div>
<div class="line"></div>
<div class="line">CryptoServerCXI.Key aesKey = cxi.generateKey(attr, 0, <span class="keyword">true</span>);</div>
</div><!-- fragment --><p> <br/>
 The following code illustrates how to use cryptographic functions: </p>
<div class="fragment"><div class="line"><span class="keyword">import</span> CryptoServerAPI.*;</div>
<div class="line"><span class="keyword">import</span> CryptoServerCXI.*;</div>
<div class="line"></div>
<div class="line"><span class="comment">// create configuration object</span></div>
<div class="line">CryptoServerConfig config = <span class="keyword">new</span> CryptoServerConfig(<span class="stringliteral">&quot;d:/temp/cxi.cfg&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// create new Cxi object with the given configuration</span></div>
<div class="line">CryptoServerCXI cxi = <span class="keyword">new</span> CryptoServerCXI(config);</div>
<div class="line"></div>
<div class="line"><span class="comment">// logon a user with password mechanism (has to be a member of group &#39;test&#39;)</span></div>
<div class="line">cxi.logonPass(<span class="stringliteral">&quot;CXI_HMAC&quot;</span>, <span class="stringliteral">&quot;utimaco&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// open previously generated AES key</span></div>
<div class="line">CryptoServerCXI.KeyAttributes attr = <span class="keyword">new</span> CryptoServerCXI.KeyAttributes(); </div>
<div class="line">attr.setGroup(<span class="stringliteral">&quot;test&quot;</span>);</div>
<div class="line">attr.setName(<span class="stringliteral">&quot;AES test key&quot;</span>);</div>
<div class="line"></div>
<div class="line">CryptoServerCXI.Key aesKey = cxi.findKey(attr, <span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// encrypt data with the key</span></div>
<div class="line">byte [] data = <span class="stringliteral">&quot;Yes we can&quot;</span>.getBytes();</div>
<div class="line"><span class="keywordtype">int</span> mech = CryptoServerCXI.MECH_MODE_ENCRYPT | CryptoServerCXI.MECH_CHAIN_CBC | CryptoServerCXI.MECH_PAD_PKCS5;</div>
<div class="line">byte [] crypto = cxi.crypt(key, mech, null, data, null);</div>
<div class="line">CryptoServerUtil.xtrace(<span class="stringliteral">&quot;encrypted data&quot;</span>, crypto); </div>
</div><!-- fragment --><h1><a class="anchor" id="algo_sec"></a>
Supported Algorithms</h1>
<hr/>
<p>The CXI firmware module supports the following algorithms and mechanisms: </p>
<table  class="doxtable">
<tr>
<th>Algorithm </th><th>Key Sizes [bit] </th><th>Mode </th><th>Chaining </th><th>Padding  </th></tr>
<tr>
<td rowspan="2">DES </td><td rowspan="2">56,112,168 </td><td>Encryption, Decryption </td><td>ECB, CBC </td><td>None, PKCS#5, ISO7816, Random  </td></tr>
<tr>
<td>Mac </td><td>CBC, CBC-Retail, CFB-Retail </td><td>None, Zero, PKCS#5, ISO7816, Random  </td></tr>
<tr>
<td rowspan="2">AES </td><td rowspan="2">128,192,256 </td><td>Encryption, Decryption </td><td>ECB, CBC, GCM, CCM </td><td>None, PKCS#5, ISO7816, Random  </td></tr>
<tr>
<td>Mac </td><td>CBC, GMAC </td><td>None, Zero, PKCS#5, ISO7816, Random  </td></tr>
<tr>
<td rowspan="2">RSA </td><td rowspan="2">512...16384 (delta = 1bit) </td><td>Encryption, Decryption </td><td>- </td><td>None, PKCS#1, PKCS-OAEP  </td></tr>
<tr>
<td>Sign, Verify </td><td>- </td><td>PKCS#1, X9.31, PKCS-PSS  </td></tr>
<tr>
<td rowspan="2">ECDSA </td><td rowspan="2">Brainpool: 160..512<br/>
 NIST: 192..521<br/>
 secp: 112..571  </td><td>Encryption, Decryption (ECIES) </td><td>- </td><td>-  </td></tr>
<tr>
<td>Sign, Verify<br/>
 (Raw Format, ASN.1 Format) </td><td>- </td><td>-  </td></tr>
<tr>
<td>DSA </td><td>P: 512..1024, Q: 160 </td><td>Sign, Verify </td><td>- </td><td>-  </td></tr>
</table>
<p>The following hash algorithms are supported: </p>
<ul>
<li>
SHA1 </li>
<li>
SHA224 </li>
<li>
SHA256 </li>
<li>
SHA384 </li>
<li>
SHA512 </li>
<li>
SHA3-224 </li>
<li>
SHA3-256 </li>
<li>
SHA3-384 </li>
<li>
SHA3-512 </li>
<li>
MD5 </li>
<li>
RipeMD160 </li>
</ul>
<h1><a class="anchor" id="install_sec"></a>
Installation</h1>
<hr/>
<h2><a class="anchor" id="step1"></a>
Step 1:</h2>
<p>Load the firmware module package (e.g. SecurityServer-XX-Series-x.x.x.mpkg) into the CryptoServer.<br/>
<br/>
 Example:<br/>
 csadm &lt;authentication&gt; LoadPkg=SecurityServer-Se2-Series-4.01.0.5.mpkg<br/>
</p>
<h2><a class="anchor" id="step2"></a>
Step 2:</h2>
<p>Create one or more users with authentication mechanism either HMAC-password or signature (RSA, ECDSA) and the following properties:<br/>
</p>
<ul>
<li>permission of level 2 in group 0 ('00000002').<br/>
</li>
<li>flags 'secure messaging with authentication' ('sma').<br/>
</li>
<li>attribute 'CXI_GROUP=&lt;key-group&gt;', where 'key-group' represents the group of keys the user will be allowed to access.<br/>
 Use wildcards ('*', '?') to assign a user to multiple groups.<br/>
<br/>
 Example:<br/>
 csadm &lt;authentication&gt; AddUser=&lt;username&gt;,00000002{CXI_GROUP=test*},hmacpwd,sma,&lt;password&gt;<br/>
</li>
</ul>
<h1><a class="anchor" id="requirements_sec"></a>
Requirements</h1>
<hr/>
<h2><a class="anchor" id="javajurisdiction"></a>
Java jurisdiction policy file</h2>
<p>There are US laws restricting the export of software containing "strong" cryptographic mechanisms. Therefore the SUN JCE provider (which is used by the CXI API) does not support "strong" encryption by default, leading to an exception in the CXI API. To remove these restrictions, please download the package called "unlimited strength jurisdiction policy files" from Oracle's website (unfortunately Oracle's general terms and conditions do not allow packaging these files).<br/>
 After this replace the old files <code>local_policy.jar</code> and <code>US_export_policy.jar</code> in the folder <code>&lt;java-installation-path&gt;\&lt;java-jre-name&gt;\lib\security</code> by the newly downloaded ones. Now the provider can make use of all cryptographic algorithms and the exception should not longer occur.</p>
<h2><a class="anchor" id="vcredist"></a>
Microsoft Visual C++ 2008 SP1 redistributable package</h2>
<p>On Microsoft Windows the CXI API requires the redistributable package runtime library to be installed. It is required to run applications developed with Visual C++ 2008 SP1 on a PC that have no Visual C++ 2008 SP1 installed. The package is automatically installed on installation of the Utimaco CryptoServer Product CD, but it also can be obtained from the Microsoft websites (a version for 32 bit and 64 bit is available). </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.2
</small></address>
</body>
</html>
